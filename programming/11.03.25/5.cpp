#include <iostream>
#include <vector>
#include <algorithm>
#include <stdio.h>
#include <map>

using namespace std;

// Наследование
class A{};
class B: public A{};

// Композиция
class A{};
class B{
    A a;
};

// необходимо определенно использовать функции вектора, чтобы появился стэк
/* 
    с наследованием стэк станет тем же самым вектором, помимо стандартных методов, будут наследованные;
    то есть работа со стеком будет как с вектором;
    в частности лучше использовать наследование, т.к. все равно у класса не будет много публичных методов, и у подклассов не будет не нужных ему методов;
    в ситуации со стеком, наверное не стоит использовать наследование, т.к. потом будет сложно изменять программу, а стэк везде будет использоваться как вектор;
    поэтому стоит использовать композицию, но стек создавать не на основе вектора, а на списке например;
*/
/* 
    с композицией не будет тех методов, что есть у вектора, только свои;
*/
class MyVector {};
class Stack: public MyVector{};

class MyVector {};
class stack{
    MyVector mv;
};

// множественное наследование
// класс без реализации
class iStack {
    public:
        virtual void push(int i) = 0;
        virtual int pop() = 0;
};
// class A: public B, public C{};

// перегрузка функций
void f(int* p, int n);
void f(vector<int>& v);

int main(){
    // Тема: google code guide
    /*
    стандарт кодирования нужен для общедоступных работ над проектом
    т.е. единый стиль
    */

    // стандарты кодирования:
    /*
    1. страж учения
    */

    /* 
    Композиция че то там чем наследование (9 строка)
    Пример: сверху в виде классов A и B
    композиция более уместна. При использовании наследования, необходимо делать его более закрытым
    */
   
    /*
    множественное наследование (38 строка)
    оно разрешается, если один из базовых классов имеет реализацию;
    */

    /*
    перегрузка оператора
    минусы:
        1. не понятна операция, например, что мы складываем тд и тп;
        2. у операторов может быть достаточно сложная реализация, т.е. они взачастую могут требовать оптимизации;
    */

    /*
    контроль доступа
    предоставляет доступ через специальные функции, желательно все заносить в приватку, что не нужно извне;
    */

    /*
    порядок описания
    сначала либо ВСЕ правила, либо паблик;
    база порядка частей: паблик, защитка, приватка;
    внутри каждой части ответление их порядка: typedef enum, const, constructor(), destructor(), methods(), variables;
    */

    /*
    перегрузка функций - фунцкии с одинаковым именем, в которых одинаковые входные данные представляются различными типами
    */

    /*
    параметры по умолчанию
    void f(int a, int b = 1);
    рекомендуется не использовать параметры по умолчанию, потому что 
    */

    return 0;
}