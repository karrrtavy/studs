# Методичка к экзамену

## Содержание

1. [Антипаттерны: Copy&Paste, спаггети-код](#1-антипаттерны-copypaste-спаггети-код)
2. [Антипаттерны: Магические числа, Hard Code, ненужная сложность](#2-антипаттерны-магические-числа-hard-code-ненужная-сложность)
3. [Препроцессор-компилятор-компоновщик](#3-препроцессор-компилятор-компоновщик)
4. [C++11: Список инициализации, лямбда-функции](#4-c11-список-инициализации-лямбда-функции)
5. [C++11: Ключевое слово auto, цикл for по коллекции](#5-c11-ключевое-слово-auto-цикл-for-по-коллекции)
6. [Google Code Guide: Страж включения, зависимости](#6-google-code-guide-страж-включения-зависимости)
7. [Google Code Guide: Встроенные функции, порядок параметров](#7-google-code-guide-встроенные-функции-порядок-параметров)
8. [Google Code Guide: Конструкторы, перегрузка функций, классы](#8-google-code-guide-конструкторы-перегрузка-функций-классы)


## 1. Антипаттерны: Copy&Paste, спаггети-код
**Антипаттерн** — шаблон неэффективного решения задачи.

### Copy&Paste
**Определение**: Создание кода с часто повторяющимися частями.
**Последствия**:
  - Дубликат кода усложняет восприятие программы и размножает ошибки из оригинала;
  - Усложнение исправления ошибок, так как изменения нужно вносить во всех копиях.

**Решение**:
  - Код-ревью;
  - Принцип DRY (Don't Repeat Yourself) — вынос общей логики в функции или классы;
  - Рефакторинг.

**Пример антипаттерна**:
```cpp
int sumInt(const vector<int>& vec) {
    int sum = 0;
    for (int num : vec)
        sum += num;
    return sum;
}

double sumDouble(const vector<double>& vec) {
    double sum = 0.0;
    for (double num : vec)
        sum += num;
    return sum;
}

void main() {
    vector<int> intVec = {n values};
    vector<double> doubleVec = {n values};
    cout << "Sum int: " << sumInt(intVec) << endl;
    cout << "Sum double: " << sumDouble(doubleVec) << endl;
    return 0;
}
```

**Пример исправления**:
```cpp
template <typename T>
T sum(const vector<T>& vec) {
    T sum = T();
    for (const T& num : vec)
        sum += num;
    return sum;
}

void main() {
    vector<int> intVec = {n values};
    vector<double> doubleVec = {n values};
    cout << "Sum int: " << sum(intVec) << endl;
    cout << "Sum double: " << sum(doubleVec) << endl;
}
```
### Спаггети-код
**Определение**: Сложный для понимания, слабо структурированный код.
**Причины**:
  - Множество связей (вложенные конструкции, goto, friend );
  - Неявные зависимости.

**Пример**:
```cpp
void f(int a, int b, int _x) {
    if (_x) {
        // another operation;
    } else {
        // another operation;
    }
}

void main() {
    f(1, 2, x);
    // something
    f(1, 2, x);
}
```

## 2. Антипаттерны. Магические числа, hard code, ненужная сложность 
### Магические числа
**Определение**: Использование числовых констант в коде.
**Пример**:
```cpp
int a = x * 8;
int b = c + 8;
float f = 34.593f;
float x = a * 34.6f;
```

**Пример исправления**:
```cpp
const int NUM_ELEMENTS = 8;
const int NUM_BITS = 8;
const int ARRAY_SIZE = 10;
const float FVALUE = 34.59f;
// также можно использовать другой метод
const int NUM_BITS_INT = sizeof(int) * 8;
```

### Hard code
**Определение**: Внедрение конкретных значений в код, вместо их вынесения в конфигурационные файлы, константы или базу данных.
**Последствия**: усложнение поддержки и изменение программы.
**Пример (условный)**:
```cpp
void connectToDB() {
    string host = "127.0.0.1";
    int port = 5432; //новость дня, postgres по умл предлагает вашу бд установить на этот порт
    string user = "admin";
    string password = "dayahuyznaet";
}

void main() {
    connectToDB();
}
```

**Пример исправления** (смысл в выносе настроек в конфиг или иное окружение, а затем их подключить):
```cpp
// у нас например есть какое нибудь окружение, БД, есть метод getenv, который может обращаться к окружению
void connectToDatabase() {
    const char* host = getenv("DB_HOST");
    const char* portStr = getenv("DB_PORT");
    const char* user = getenv("DB_USER");
    const char* password = getenv("DB_PASS");
}

void main() {
    connectToDatabase();
} 
// смысл в том, чтобы данные не находились в исходниках
```

### Ненужная сложность (неоправданно универсальное решение)
**Определение**: Намеренно усложненный код.
**Причины**:
  - Избыток абстракций, классов, паттернов;
  - Ненужные уровни наследования;
  - Гибкое решение там, где возможен простой код.

**Пример**:
```cpp
// из проблем: 2 класса для простой проверки, виртуальный метод и динамическая память
class NumberValidator {
public:
    virtual bool validate(int) = 0;
    virtual ~NumberValidator() {}
};

class EvenNumberValidator : public NumberValidator {
public:
    bool validate(int num) override {
        return num % 2 == 0;
    }
};

void main() {
    NumberValidator* validator = new EvenNumberValidator();
    cout << validator->validate(4);
    delete validator;
}
```

**Пример решения**:
```cpp
bool isEven(int num) {
    return num % 2 == 0;
}

void main() {
    cout << isEven(4);
}
```

## 3. Препроцессор-компилятор-компоновщик
**Препроцессор** - программа для обработки текста. Он преобразует данные в соответствии с директивами препроцессора. Если данные не содержат директив препроцессора, то они остаются без изменений. Препроцессор может существовать как отдельная программа, так и быть интегрированным в компилятор.
**Компилятор** - программа, которая переводит исходный код в инструкции процессора (как объектный файл, на схеме указано). При синтаксических ошибках объектный файл не создается.
**Компоновщик** - на слэнге это линкер. Это программа, производящая линковку, сборку. Он принимает на вход один или несколько модулей и собирает по ним исполнимый модуль.

В общем, это этапы процесса трансляции исходника в виде текстового файла в представлении, которое может быть выполнено процессором.

**Сборка компоновщика**
Всем известно, что сборка программы происходит за счет другой специальной программы - компоновщика. Роль компоновщика определяет размещение программы в памяти (ну распределение памяти в общем), также настраивает адреса в памяти: относительные адреса заменяются абсолютными адресами распределенной памяти.

![Схема](programming/11.03.25/preproccessing_projects.drawio.png)

## 4. C++11. Список инициализации, лямбда функции
### Список инициализации
**Определение**: единый синтаксис инициализации переменных, контейнеров и объектов с помощью {}.
**Преимущества**:
  - Универсальность (работает для всех типов: примитивы, массивы, классы, контейнеры);
  - Ограничение преобразования (например: double -> int без явного приведения);
  - Устранение неоднозначности при вызове конструкторов.

**Пример**:
```cpp
int x{5};
double y{3.14};     

int arr[]{1, 2, 3};               
vector<int> vec{10, 20, 30}; 

class Point {
public:
    int x, y;
    Point(int a, int b) : x{a}, y{b} {}
};
Point p{1, 2};
```

**Существует особенность**, если тип имеет <code>initializer_list</code> в конструкторе, то вызов происходит предпочтительно:
```cpp
vector<int> v{5}; // один элемент, равный 5
vector<int> v(5); // 5 элементов, равных 0
```

### Лямбда функция
**Определение**: Такая функция, которую можно объявить непосредственно в месте использования (то есть объявляем и используем на лету). Также ее можно передавать в качестве параметра (пример с алгоритмом).
**Пример 1**:
```cpp
// пример с простой лямбдой
vector<int> v = {1, 3, 5, 2, 4, 1, 5, 7, 4, 9, 3, 4};

for_each(
    v.begin(), 
    v.end(), 
    [](int x){cout << x << ' ';} // если что, то вот она
);
// у нее прикольный прикол, что используется на лету, а также, до этого момента, нестандартное начало объявления, где [] - захват переменной, смотри пример ниже. 
```

**Пример 2**:
```cpp
// пример с захватом переменной
vector<int> v = {1, 3, 5, 2, 4, 1, 5, 7, 4, 9, 3, 4};
int summ = 0;
for_each(
    v.begin(), 
    v.end(),
    [&summ](int x){
        cout << x << ' ';
        summ += x;
    }
);
// [x] - захват по значению;
// [&x] - захват по ссылке.
```

**Пример 3**:
```cpp
vector<int> nums{1, 2, 3, 4};
sort(nums.begin(), nums.end(), [](int a, int b) { return a > b; });
// в методе sort лямбда функция передается в качестве параметра.
```

## 5. C++11. auto, for по коллекции
### auto
**Определение (из дипсика)**: механизм автоматического вывода типа переменной на этапе компиляции.
**Преимущества**:
  - упрощает код (в особенности с итераторами);
  - Уменьшает вероятность ошибок при изменении типов;
  - Работает с шаблонами и лямбда функциями.

**Пример**:
```cpp
auto x = 5; // int
auto y = 3.14; // double
auto z = "Hello"; // const char*

vector<int> vec{1, 2, 3};
auto it = vec.begin(); // с этим каждый встречался не раз -> vector<int>::iterator

template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
auto result = add(2, 3.5); // double
```

В ней также есть прикол, что она требует явной инициализации, то есть просто объявить <code>auto x;</code> не получится, нужно указать значение. Двигаясь от C++20, auto можно использовать в передаваемых параметрах функций (код с дипсика ясно дает это понять). 

### for по коллекции
** Определение**: Упрощенный синтаксис для итерации по контейнерам. 
**Преимущества**:
  - Избавляет от ручного управления итератором (все же надеюсь помнят);
  - Работает с любым типом, имеющий begin() и end();
  - Поддерживает auto для краткости.

**Пример**:
```cpp
//цикл for по коллекции
vector<int> v = {1, 2, 3};

for(auto it = v.begin(); it != v.end(); ++it)
    cout << *it << ' ';

cout << endl;

for(vector<int>::iterator it = v.begin(); it != v.end(); ++it)
    cout << *it << ' ';

cout << endl;

for(int& i : v) //тот самый цикл for по коллекции в короткой записи
    cout << i << ' ';
/* объявляем тип итератора по коллекции, и саму коллекцию, 
работает с контейнерами у которых есть метды begin() и end(),
и их методы должны возвращать итератор.
с апперсантом i может менять значения контейнера, а без & просто для вывода.
auto упрощает запись, при этом необходимо знать что за тип,
и есть ли смысл упрощать запись */
```

## 6. Google Code Guide. Страж включения, зависимости в заголовочных файлах
### Страж включения
**Определение**: условно это техника предотвращения множественного включения одного заголовочного файла в проект.
**Как работает**: использует директивы препроцессора <code>#ifndef, #define, #endif</code> для блокировки повторного включения.
**Пример:**  
```cpp
#ifndef MATRIX_H
#define MATRIX_H

class Matrix { /*...*/ };

#endif  // MATRIX_H
```

Для C++11 существует альтернатива: <code>#pragma once</code>.
Это может быть важным, потому что возможно исключение ошибок переопределения функций и классов, а также исключает повторную обработку кода, что ускоряет компиляцию.

### Зависимости в заголовочных файлах
**Определения нет, но**: не используйте <code>#include</code>, если достаточно предварительного объявления. Это в общем минимизирует зависимости, также можно включать только то, что нужно для объявления в заголовке.
**Как разделяются зависимости**:
  - Заголовочные файлы: только объявления, без реализации;
  - Исходные файлы: полные <code>#include</code> для реализации.

**Пример**:
```cpp
// какой нибудь My.h
#ifndef MY_H
#define MY_H
class X;
class Y {
    X* x;
public:
    Y();
    ~Y();
};
#endif
```
```cpp
// My.cpp
#include "My.h"

Y::Y(){x = new X();}
Y::Y(){delete x;}
void main(){}
```

## 7. Google Code Guide. Встроенные функции, порядок параметров
### Встроенные функции
**Что это?**: Функции, объявленные с ключевым словом `inline`, тело которых подставляется в месте вызова (а не вызывается как отдельная функция).
**Причины использования**:
  - Маленькие функции (1-3 строки);
  - Часто вызываемые функции (например, геттеры/сеттеры);
  - Функции в заголовочных файлах (во избежание ошибок линковки).

**Правила GCG**:
- Избегайте `inline` для сложных функций (> 10 строк);
- Не используйте `inline` для виртуальных функций (компилятор может проигнорировать);
- В классах: методы, определенные внутри класса, неявно становятся `inline`.  

**Пример**:
```cpp
inline void f() {
    // here for 3 rows code
}
// если в теле функции >3 строк, то это косяк для inline функции по GCG
```

| Плюсы | Минусы |
|-------|--------|
|Уменьшение накладных расходов на вызов функции|Увеличение размера бинарника (при условии, что функция вызывается много раз)|
|Подходит для шаблонных функций (они должны быть в заголовках)||

### Порядок параметров функции
**Рекомендации GCG**:
- Входные параметры перед выходными:
  - Сначала параметры, которые читаются, затем те, которые изменяются.
- Единый порядок во всем проекте.
- Параметры с дефолтными значениями должны находиться в конце.

**Пример правильного порядка**:
```cpp
// входные параметры a, b перед выходными result
void calculate(int a, int b, int& result);
```
**Пример с необязательными параметрами**:
```cpp
// необязательный параметр в конце
void drawCircle(int x, int y, int radius, Color color = Color::Black);
```
**Пример для классов**:
```cpp
class Player {
public:
    // this неявно считается первым параметром
    // напомню, что такое this - указатель на текущий объект данного класса
    void move(int dx, int dy); // dx, dy — входные параметрыуказатель на текущий объект данного класса
};
```

 ## 8. Google Code Guide. Конструкторы, перегрузка функций, классы
 ### Конструкторы
**Основные правила:**
1. **Явные конструкторы:**
   - Помечайте конструкторы с одним параметром как `explicit` (запрещает неявные преобразования)
```cpp
class String {
public:
    explicit String(int size); // запрещает String s = 10;
};
```

2. **Делегирующие конструкторы (C++11):**
```cpp
class Circle {
public:
    Circle() : Circle(1.0) {} // делегирует конструктору с параметром
    explicit Circle(double r) : radius(r) {}
};
```

3. **Инициализация членов класса:**
   - Использование списка инициализации вместо присваивания в теле конструктора.
```cpp
Point::Point(int x, int y) : x_(x), y_(y) {}
```

### Перегрузка функций
**Рекомендации:**
1. **Четкие различия:**
   - Перегружайте только когда варианты логически выполняют одну задачу.
```cpp
void print(int value);
void print(const string& value);
```

2. **Избегание двусмысленности:**
```cpp
void process(int x);
void process(double x); // может вызвать неоднозначность при process(5)
```

3. **Параметры по умолчанию vs перегрузка:**
   - Использование перегрузки, когда логика существенно отличается.
```cpp
// лучше две функции:
void connect();
void connect(const string& url);
// чем одна с параметром по умолчанию:
void connect(const string& url = "");
```

### Классы
**Стиль GCG:**
1. **Порядок объявления**:
```cpp
class MyClass {
public: // условный API для пользователей
protected: // для наследников
private: // внутренняя реализация
};
```

2. **Инкапсуляция:**
   - Члены класса должны быть `private` по умолчанию;
   - Используйте геттеры/сеттеры только когда необходимо.
3. **Размер классов:**
   - Избегайте "божественных классов" (god objects);
   - Разделяйте ответственность между несколькими классами.
4. **Наследование:**
   - Композиция предпочтительнее наследования.

**Пример неправильного класса**:
```cpp
class BadExample {
public:
    BadExample(int x) { data = x; } // неявное присваивание
    
    void process(int x); // слишком общее название
    void process(); // совсем другая логика
    
    int data; // публичное поле
};
```

**Пример правильного класса**:
```cpp
class Rational {
public:
    explicit Rational(int numerator, int denominator = 1);
    
    int numerator() const { return num_; }
    int denominator() const { return den_; }
    
    Rational operator+(const Rational& other) const;

private:
    int num_;
    int den_;    
};
```

## 9. Шаблоны Проектирования. Определение, назначение. Фабричный метод
**Шаблоны проектирования** - это хорошее решение типовой задачи, возникающей при разработке.
**Назначение**:
- Повышение повторной используемости кода;
- Упрощение поддержки и модификации системы;
- Снижение вероятности ошибок;
- Ускорение процесса разработки.

### Фабричный метод (Factory Method)
**Относится к**: Порождающим шаблонам, а то есть он создает объекты. Также он использует наследование (делегирование создания подклассам).
**Назначение**:
- Определяет интерфейс для создания объекта;
- Позволяет подклассам изменять тип создаваемых объектов.

**Пример фабричного метода**:
```cpp
class DocumentCreator {
public:
    virtual Document* createDocument() = 0;
    virtual ~DocumentCreator() {}
};

class PDFCreator : public DocumentCreator {
public:
    Document* createDocument() override {
        return new PDFDocument();
    }
};

class WordCreator : public DocumentCreator {
public:
    Document* createDocument() override {
        return new WordDocument();
    }
};

DocumentCreator* creator = new PDFCreator();
Document* doc = creator->createDocument();
```

|Преимущества|Недостатки|
|------------|----------|
|Избегает жёсткой привязки к конкретным классам|Усложнение кода (необходимость создания параллельной иерархии классов)|
|Упрощает добавление новых типов продуктов|Требует предварительного проектирования|
|Реализует принцип открытости/закрытости||

**Применение:**
- Когда система должна оставаться независимой от типов создаваемых объектов;
- Когда нужно предоставить возможность расширения для будущих подклассов;
- В библиотеках и фреймворках.

## 10. Шаблоны Проектирования. Определение, назначение. Пул объектов
**Шаблоны проектирования** - это хорошее решение типовой задачи, возникающей при разработке.
**Назначение**:
- Повышение повторной используемости кода;
- Упрощение поддержки и модификации системы;
- Снижение вероятности ошибок;
- Ускорение процесса разработки.

### Пул объектов
**Суть шаблона**: Шаблон нужен для повторного использования объектов вместо их постоянного создания и уничтожения. 
**Относится к**: Порождающим шаблонам

**Суть проблемы**:
1. Частое создание/удаление "тяжёлых" объектов (например, подключений к БД)
2. Высокая стоимость инициализации объектов
3. Фрагментация памяти

**Пример:**
 ```cpp
// предварительное создание и кэширование объектов
class ConnectionPool {
private:
    stack<DatabaseConnection*> pool;
    mutex poolMutex;
    
public:
    DatabaseConnection* acquire() {
        lock_guard<mutex> lock(poolMutex);
        if (pool.empty()) {
            return new DatabaseConnection();
        }
        auto* conn = pool.top();
        pool.pop();
        return conn;
    }
    
    void release(DatabaseConnection* conn) {
        lock_guard<mutex> lock(poolMutex);
        pool.push(conn);
    }
    
    ~ConnectionPool() {
        while (!pool.empty()) {
            delete pool.top();
            pool.pop();
        }
    }
};

ConnectionPool pool;
auto* conn = pool.acquire();
conn->executeQuery("...");
pool.release(conn);
 ```

**Особенности:**
- Экономия времени на создании объектов;
- Снижение нагрузки на сборщик мусора;
- Контроль над количеством экземпляров.

|Преимущества|Недостатки|
|------------|----------|
|Экономия времени на создании объектов|Усложнение кода|
|Снижение нагрузки на сборщик мусора|Необходимость ручного управления объектами|
|Контроль над количеством экземпляров|Риск "утечки" объектов (если не вернуть в пул)|

## 11. Шаблоны Проектирования. Определение, назначение. Наблюдатель
**Шаблоны проектирования** - это хорошее решение типовой задачи, возникающей при разработке.
**Назначение**:
- Повышение повторной используемости кода;
- Упрощение поддержки и модификации системы;
- Снижение вероятности ошибок;
- Ускорение процесса разработки.

### Наблюдатель (Observer)

**Относится к**: Поведенческим шаблонам
**Суть проблемы**:
- Необходимость уведомления множества объектов об изменениях;
- Жесткая связь между объектами;
- Неэффективные механизмы опроса.

**Пример решения:**
```cpp
class Document {};
class Figure {};
class Point {};

class InputObserver {
public:
    virtual void onKeyPressed(string key) {}
    virtual void onMouseMoved(Point position) {}
    virtual void onMousePressed(string button) {}
};

class Observer {
public:
    // virtual void update(Document* doc) = 0;
    virtual void onChangeProperties(Document* doc, Figure* f) {}
    
    virtual void onSetLink(Figure* parent, Figure* child) {} 
    virtual void onRemoveLink(Figure* parent, Figure* child) {} 

    virtual void onAddFigure(Figure* f) {}
    virtual void onRemoveFigure(Figure* f) {}
};

class FigureCountObserver : public Observer {
public:
    void onAddFigure(Figure* f) {}
    void onRemoveFigure(Figure* f) {}
};

class DocumentSctructureObserver : public Observer {
public:    
    void onSetLink(Figure* parent, Figure* child) {} 
    void onRemoveLink(Figure* parent, Figure* child) {} 
    void onAddFigure(Figure* f) {}
    void onRemoveFigure(Figure* f) {}
};

class LogObserver : public Observer {
public:
    void onChangeProperties(Document* doc, Figure* f) {}
    void onSetLink(Figure* parent, Figure* child) {} 
    void onRemoveLink(Figure* parent, Figure* child) {} 
    void onAddFigure(Figure* f) {}
    void onRemoveFigure(Figure* f) {}
}; 
```

|Преимущества|Недостатки|
|------------|----------|
|Слабая связность между компонентами|Риск производительности при большом числе наблюдателей|

**Применения:**
- Уведомления;
- Логирование;
- Сохранение последнего действия.

![Схема наблюдателя](programming/observer1.png)

**Другой пример + его схема** (мне он больше нравится):
```cpp
class Document;

class Observer {
public:
    virtual void update(Document* doc) = 0;
};

class Document {
    vector<int> state;
    vector<Observer*> observers;
    void notify() {
        for (int i =0; i < observers.size(); ++i)
            observers[i]->update(this);
    }
public:
    void add(int a) {
        state.push_back(a);
        notify();
    }
    virtual void getState(Observer* o) = 0;

    void remove(int index) {
        state.erase(state.begin() + index);
        notify();
    }
    void attach(Observer* o) {
        observers.push_back(o);
    }
    void dettach(Observer* o) {
        observers.erase(find(observers.begin(), observers.end(), o));
    }
};

class PrintObserver : public Observer {
public:
    void update(Document* doc) {
        vector<int>& state = doc->getState();
        for (int i = 0; i < state.size(); ++i)
            cout << state[i] << ' ';
        cout << endl;
};

class SumObserver : public Observer {
public:
    void update(Document* doc) {
        int summ = 0;
        vector<int>& state = doc->getState();
        for (int i = 0; i < state.size(); ++i) 
            summ += state[i];
        cout << "Summ: " << summ << endl; 
    }
};

void main(){
    Document doc;
    
    PrintObserver po;
    doc.attach(&po);

    SumObserver so;
    doc.attach(&so);

    for (int i = 0; i < 10; ++i)
        doc.add(i);
}
```

![Схема наблюдателя](programming/observer2.png)

## 12. Отладка программ. Научный метод отладки


















